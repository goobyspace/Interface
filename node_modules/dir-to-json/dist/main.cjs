"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  INVALID_OPTIONS_ERROR: () => INVALID_OPTIONS_ERROR,
  INVALID_PATH_ERROR: () => INVALID_PATH_ERROR,
  default: () => dirToJson
});
module.exports = __toCommonJS(main_exports);

// src/createDirectoryObject.ts
var import_promises = __toESM(require("fs/promises"), 1);
var import_path = __toESM(require("path"), 1);

// src/options/sortByFileOrDir.ts
function sortByFileOrDir(childrenArray) {
  return childrenArray.sort(function(a, b) {
    if (a.type === "file" && b.type === "directory") {
      return 1;
    } else if (a.type === "directory" && b.type === "file") {
      return -1;
    } else {
      return 0;
    }
  });
}

// src/createDirectoryObject.ts
async function createDirectoryObject(rootDir, fileName, options) {
  const { sortType = true } = options;
  let currentDir = import_path.default.normalize(rootDir + "/" + fileName);
  currentDir = currentDir.replace(/\/+$/, "");
  const stats = await import_promises.default.stat(currentDir);
  const fileType = stats.isFile() ? "file" : "directory";
  const fileInfo = {
    parent: import_path.default.relative(rootDir, import_path.default.dirname(currentDir)),
    path: import_path.default.relative("./" + rootDir, "./" + currentDir),
    name: import_path.default.basename(currentDir),
    type: fileType
  };
  if (fileInfo.type === "file") {
    return fileInfo;
  } else {
    fileInfo.children = [];
  }
  const files = await import_promises.default.readdir(currentDir);
  const promises = files.map((newFileName) => {
    return createDirectoryObject(rootDir, fileName + "/" + newFileName, options);
  });
  let data = await Promise.all(promises);
  if (sortType) {
    data = sortByFileOrDir(data);
  }
  fileInfo.children = data;
  return fileInfo;
}

// src/main.ts
var INVALID_PATH_ERROR = `"path" parameter must be a string`;
var INVALID_OPTIONS_ERROR = `"options" parameter must be an object`;
async function dirToJson(path2, options = {}) {
  if (typeof path2 !== "string") {
    return Promise.reject(INVALID_PATH_ERROR);
  }
  if (typeof options !== "object") {
    return Promise.reject(INVALID_OPTIONS_ERROR);
  }
  return await createDirectoryObject(path2, "", options);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  INVALID_OPTIONS_ERROR,
  INVALID_PATH_ERROR
});
//# sourceMappingURL=main.cjs.map