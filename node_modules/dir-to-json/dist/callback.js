// src/createDirectoryObject.ts
import fs from "fs/promises";
import path from "path";

// src/options/sortByFileOrDir.ts
function sortByFileOrDir(childrenArray) {
  return childrenArray.sort(function(a, b) {
    if (a.type === "file" && b.type === "directory") {
      return 1;
    } else if (a.type === "directory" && b.type === "file") {
      return -1;
    } else {
      return 0;
    }
  });
}

// src/createDirectoryObject.ts
async function createDirectoryObject(rootDir, fileName, options) {
  const { sortType = true } = options;
  let currentDir = path.normalize(rootDir + "/" + fileName);
  currentDir = currentDir.replace(/\/+$/, "");
  const stats = await fs.stat(currentDir);
  const fileType = stats.isFile() ? "file" : "directory";
  const fileInfo = {
    parent: path.relative(rootDir, path.dirname(currentDir)),
    path: path.relative("./" + rootDir, "./" + currentDir),
    name: path.basename(currentDir),
    type: fileType
  };
  if (fileInfo.type === "file") {
    return fileInfo;
  } else {
    fileInfo.children = [];
  }
  const files = await fs.readdir(currentDir);
  const promises = files.map((newFileName) => {
    return createDirectoryObject(rootDir, fileName + "/" + newFileName, options);
  });
  let data = await Promise.all(promises);
  if (sortType) {
    data = sortByFileOrDir(data);
  }
  fileInfo.children = data;
  return fileInfo;
}

// src/main.ts
var INVALID_PATH_ERROR = `"path" parameter must be a string`;
var INVALID_OPTIONS_ERROR = `"options" parameter must be an object`;
async function dirToJson(path2, options = {}) {
  if (typeof path2 !== "string") {
    return Promise.reject(INVALID_PATH_ERROR);
  }
  if (typeof options !== "object") {
    return Promise.reject(INVALID_OPTIONS_ERROR);
  }
  return await createDirectoryObject(path2, "", options);
}

// src/callback.ts
var INVALID_CALLBACK_ERROR = `The "dir-to-json/callback" module requires a valid callback function`;
function callback(path2, optionsOrCallbackFn, callbackFn) {
  let options;
  if (typeof optionsOrCallbackFn === "function") {
    options = void 0;
    callbackFn = optionsOrCallbackFn;
  } else {
    options = optionsOrCallbackFn;
  }
  if (typeof callbackFn !== "function") {
    throw new Error(INVALID_CALLBACK_ERROR);
  }
  dirToJson(path2, options).then((dirTree) => {
    callbackFn(void 0, dirTree);
  }).catch((err) => {
    callbackFn(err);
  });
}
var callback_default = callback;
export {
  INVALID_CALLBACK_ERROR,
  callback_default as default
};
//# sourceMappingURL=callback.js.map