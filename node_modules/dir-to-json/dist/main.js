// src/createDirectoryObject.ts
import fs from "fs/promises";
import path from "path";

// src/options/sortByFileOrDir.ts
function sortByFileOrDir(childrenArray) {
  return childrenArray.sort(function(a, b) {
    if (a.type === "file" && b.type === "directory") {
      return 1;
    } else if (a.type === "directory" && b.type === "file") {
      return -1;
    } else {
      return 0;
    }
  });
}

// src/createDirectoryObject.ts
async function createDirectoryObject(rootDir, fileName, options) {
  const { sortType = true } = options;
  let currentDir = path.normalize(rootDir + "/" + fileName);
  currentDir = currentDir.replace(/\/+$/, "");
  const stats = await fs.stat(currentDir);
  const fileType = stats.isFile() ? "file" : "directory";
  const fileInfo = {
    parent: path.relative(rootDir, path.dirname(currentDir)),
    path: path.relative("./" + rootDir, "./" + currentDir),
    name: path.basename(currentDir),
    type: fileType
  };
  if (fileInfo.type === "file") {
    return fileInfo;
  } else {
    fileInfo.children = [];
  }
  const files = await fs.readdir(currentDir);
  const promises = files.map((newFileName) => {
    return createDirectoryObject(rootDir, fileName + "/" + newFileName, options);
  });
  let data = await Promise.all(promises);
  if (sortType) {
    data = sortByFileOrDir(data);
  }
  fileInfo.children = data;
  return fileInfo;
}

// src/main.ts
var INVALID_PATH_ERROR = `"path" parameter must be a string`;
var INVALID_OPTIONS_ERROR = `"options" parameter must be an object`;
async function dirToJson(path2, options = {}) {
  if (typeof path2 !== "string") {
    return Promise.reject(INVALID_PATH_ERROR);
  }
  if (typeof options !== "object") {
    return Promise.reject(INVALID_OPTIONS_ERROR);
  }
  return await createDirectoryObject(path2, "", options);
}
export {
  INVALID_OPTIONS_ERROR,
  INVALID_PATH_ERROR,
  dirToJson as default
};
//# sourceMappingURL=main.js.map