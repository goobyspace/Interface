{"version":3,"sources":["../src/createDirectoryObject.ts","../src/options/sortByFileOrDir.ts","../src/main.ts"],"sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\nimport sortByFileOrDir from \"./options/sortByFileOrDir\";\n\nexport interface Options {\n\tsortType?: boolean;\n}\n\nexport interface FileInfo {\n\tparent: string;\n\tpath: string;\n\tname: string;\n\ttype: string;\n\tchildren?: FileInfo[];\n}\n\nexport default async function createDirectoryObject(\n\trootDir: string,\n\tfileName: string,\n\toptions: Options\n): Promise<FileInfo> {\n\tconst { sortType = true } = options;\n\n\tlet currentDir = path.normalize(rootDir + \"/\" + fileName);\n\n\t// Remove any trailing slashes. This prevents an error if rootDir is actually a file.\n\tcurrentDir = currentDir.replace(/\\/+$/, \"\");\n\n\t// Check if file or directory\n\tconst stats = await fs.stat(currentDir);\n\tconst fileType = stats.isFile() ? \"file\" : \"directory\";\n\n\tconst fileInfo: FileInfo = {\n\t\tparent: path.relative(rootDir, path.dirname(currentDir)),\n\t\tpath: path.relative(\"./\" + rootDir, \"./\" + currentDir),\n\t\tname: path.basename(currentDir),\n\t\ttype: fileType,\n\t};\n\n\tif (fileInfo.type === \"file\") {\n\t\t// It's a file so we can't go any deeper\n\t\treturn fileInfo;\n\t} else {\n\t\t// It's a directory, so prep adding children\n\t\tfileInfo.children = [];\n\t}\n\n\tconst files = await fs.readdir(currentDir);\n\n\t// Recursively examine directory's children\n\tconst promises = files.map((newFileName) => {\n\t\treturn createDirectoryObject(\n\t\t\trootDir,\n\t\t\tfileName + \"/\" + newFileName,\n\t\t\toptions\n\t\t);\n\t});\n\n\t// Wait for all children to complete\n\tlet data = await Promise.all(promises);\n\tif (sortType) {\n\t\tdata = sortByFileOrDir(data);\n\t}\n\tfileInfo.children = data;\n\n\treturn fileInfo;\n}\n","import { FileInfo } from \"../createDirectoryObject\";\n\nexport default function sortByFileOrDir(childrenArray: FileInfo[]) {\n\t// Move directories to the beginning of the array\n\treturn childrenArray.sort(function (a, b) {\n\t\tif (a.type === \"file\" && b.type === \"directory\") {\n\t\t\treturn 1;\n\t\t} else if (a.type === \"directory\" && b.type === \"file\") {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t});\n}\n","import createDirectoryObject, { Options } from \"./createDirectoryObject\";\n\nexport const INVALID_PATH_ERROR = `\"path\" parameter must be a string`;\nexport const INVALID_OPTIONS_ERROR = `\"options\" parameter must be an object`;\nexport default async function dirToJson(path: string, options: Options = {}) {\n\tif (typeof path !== \"string\") {\n\t\treturn Promise.reject(INVALID_PATH_ERROR);\n\t}\n\tif (typeof options !== \"object\") {\n\t\treturn Promise.reject(INVALID_OPTIONS_ERROR);\n\t}\n\n\treturn await createDirectoryObject(path, \"\", options);\n}\n"],"mappings":";AAAA;AACA;;;ACCe,yBAAyB,eAA2B;AAElE,SAAO,cAAc,KAAK,SAAU,GAAG,GAAG;AACzC,QAAI,EAAE,SAAS,UAAU,EAAE,SAAS,aAAa;AAChD,aAAO;AAAA,IACR,WAAW,EAAE,SAAS,eAAe,EAAE,SAAS,QAAQ;AACvD,aAAO;AAAA,IACR,OAAO;AACN,aAAO;AAAA,IACR;AAAA,EACD,CAAC;AACF;;;ADGA,qCACC,SACA,UACA,SACoB;AACpB,QAAM,EAAE,WAAW,SAAS;AAE5B,MAAI,aAAa,KAAK,UAAU,UAAU,MAAM,QAAQ;AAGxD,eAAa,WAAW,QAAQ,QAAQ,EAAE;AAG1C,QAAM,QAAQ,MAAM,GAAG,KAAK,UAAU;AACtC,QAAM,WAAW,MAAM,OAAO,IAAI,SAAS;AAE3C,QAAM,WAAqB;AAAA,IAC1B,QAAQ,KAAK,SAAS,SAAS,KAAK,QAAQ,UAAU,CAAC;AAAA,IACvD,MAAM,KAAK,SAAS,OAAO,SAAS,OAAO,UAAU;AAAA,IACrD,MAAM,KAAK,SAAS,UAAU;AAAA,IAC9B,MAAM;AAAA,EACP;AAEA,MAAI,SAAS,SAAS,QAAQ;AAE7B,WAAO;AAAA,EACR,OAAO;AAEN,aAAS,WAAW,CAAC;AAAA,EACtB;AAEA,QAAM,QAAQ,MAAM,GAAG,QAAQ,UAAU;AAGzC,QAAM,WAAW,MAAM,IAAI,CAAC,gBAAgB;AAC3C,WAAO,sBACN,SACA,WAAW,MAAM,aACjB,OACD;AAAA,EACD,CAAC;AAGD,MAAI,OAAO,MAAM,QAAQ,IAAI,QAAQ;AACrC,MAAI,UAAU;AACb,WAAO,gBAAgB,IAAI;AAAA,EAC5B;AACA,WAAS,WAAW;AAEpB,SAAO;AACR;;;AEhEO,IAAM,qBAAqB;AAC3B,IAAM,wBAAwB;AACrC,yBAAwC,OAAc,UAAmB,CAAC,GAAG;AAC5E,MAAI,OAAO,UAAS,UAAU;AAC7B,WAAO,QAAQ,OAAO,kBAAkB;AAAA,EACzC;AACA,MAAI,OAAO,YAAY,UAAU;AAChC,WAAO,QAAQ,OAAO,qBAAqB;AAAA,EAC5C;AAEA,SAAO,MAAM,sBAAsB,OAAM,IAAI,OAAO;AACrD;","names":[]}